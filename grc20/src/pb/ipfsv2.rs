// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(enumeration = "ActionType", tag = "2")]
    pub r#type: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Edit {
    /// ------------------
    /// version and type are defined on every IPFS action
    /// ------------------
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// Should always be 1 for ADD_EDIT
    #[prost(enumeration = "ActionType", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub ops: ::prost::alloc::vec::Vec<Op>,
    #[prost(string, repeated, tag = "6")]
    pub authors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// @TODO: Use oneof instead of these weird optional state machines
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Op {
    #[prost(enumeration = "OpType", tag = "1")]
    pub r#type: i32,
    /// *
    /// Used when setting batch ops or deleting an entity
    #[prost(message, optional, tag = "2")]
    pub entity: ::core::option::Option<Entity>,
    /// *
    /// Used when creating or deleting a relation
    #[prost(message, optional, tag = "3")]
    pub relation: ::core::option::Option<Relation>,
    #[prost(message, optional, tag = "4")]
    pub property: ::core::option::Option<PropertyDefinition>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropertyDefinition {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub r#type: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub name: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relation {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub r#type: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub from_entity: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub from_property: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub to_entity: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub to_space: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "7")]
    pub entity: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub index: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entity {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub properties: ::prost::alloc::vec::Vec<PropertyValue>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropertyValue {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// If we are in an UNSET_PROPERTIES op we don't
    /// need to pass the value
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Value>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub options: ::core::option::Option<Options>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Options {
    #[prost(bytes = "vec", tag = "1")]
    pub unit: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub format: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActionType {
    Unknown = 0,
    AddEdit = 1,
    ImportSpace = 2,
    ArchiveSpace = 3,
}
impl ActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ACTION_TYPE_UNKNOWN",
            Self::AddEdit => "ADD_EDIT",
            Self::ImportSpace => "IMPORT_SPACE",
            Self::ArchiveSpace => "ARCHIVE_SPACE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTION_TYPE_UNKNOWN" => Some(Self::Unknown),
            "ADD_EDIT" => Some(Self::AddEdit),
            "IMPORT_SPACE" => Some(Self::ImportSpace),
            "ARCHIVE_SPACE" => Some(Self::ArchiveSpace),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OpType {
    Unknown = 0,
    CreateEntity = 1,
    UpdateEntity = 2,
    DeleteEntity = 3,
    CreateRelation = 4,
    DeleteRelation = 5,
    ReorderRelation = 6,
    UnsetProperties = 7,
    CreateProperty = 8,
    ArchiveProperty = 9,
    MoveEntity = 10,
    MergeEntities = 11,
    /// @TODO impl enables us to map an entity with it. What happens
    /// if there's more than one CREATE_SPACE for the same address? ignore?
    /// Should this be an Op instead of an action?
    /// SET_SPACE_ENTITY = 4;
    BranchEntity = 12,
}
impl OpType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "OP_TYPE_UNKNOWN",
            Self::CreateEntity => "CREATE_ENTITY",
            Self::UpdateEntity => "UPDATE_ENTITY",
            Self::DeleteEntity => "DELETE_ENTITY",
            Self::CreateRelation => "CREATE_RELATION",
            Self::DeleteRelation => "DELETE_RELATION",
            Self::ReorderRelation => "REORDER_RELATION",
            Self::UnsetProperties => "UNSET_PROPERTIES",
            Self::CreateProperty => "CREATE_PROPERTY",
            Self::ArchiveProperty => "ARCHIVE_PROPERTY",
            Self::MoveEntity => "MOVE_ENTITY",
            Self::MergeEntities => "MERGE_ENTITIES",
            Self::BranchEntity => "BRANCH_ENTITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OP_TYPE_UNKNOWN" => Some(Self::Unknown),
            "CREATE_ENTITY" => Some(Self::CreateEntity),
            "UPDATE_ENTITY" => Some(Self::UpdateEntity),
            "DELETE_ENTITY" => Some(Self::DeleteEntity),
            "CREATE_RELATION" => Some(Self::CreateRelation),
            "DELETE_RELATION" => Some(Self::DeleteRelation),
            "REORDER_RELATION" => Some(Self::ReorderRelation),
            "UNSET_PROPERTIES" => Some(Self::UnsetProperties),
            "CREATE_PROPERTY" => Some(Self::CreateProperty),
            "ARCHIVE_PROPERTY" => Some(Self::ArchiveProperty),
            "MOVE_ENTITY" => Some(Self::MoveEntity),
            "MERGE_ENTITIES" => Some(Self::MergeEntities),
            "BRANCH_ENTITY" => Some(Self::BranchEntity),
            _ => None,
        }
    }
}
